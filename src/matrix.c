/**
** @file   matrix.с
** @author Alexander Smyslov <smyslov@selby.su>
** @brief  Позволяет удобно манипулировать динамическими матрицами.
** Модуль реализует новый тип данных - динамический двумерный массив,
** позволяющий создавать матрицы не только константного размера
** (определенного еще до выполнения программы), но и при помощи
** переменных значений. Так же модуль предоставляет функции,
** облегчающие работу с матрицами.
**/

#include "matrix.h"

/**
** @brief Создает динамический двумерный массив с числом элементов,
** соответствующим произведению количества строк и столбцов,
** и возвращает указатель на нее. Третьим аргументом в функцию передается
** размер элементов матрицы в байтах, что позволяет создавать массивы
** любого типа данных. Матрица создается аллоцированием динамической памяти.
** Память выделяется дважды: для самой структуры и для массива с данными.
** Потому для полного освобождения памяти необходимо либо воспользоваться
** функцией `matrix_delete()`, либо последовательно освободить
** сначала указатель `matrix::arr`, а затем и саму структуру `t_matrix`.
** 
** @param rows количество строк
** @param cols количество колонок
** @param size размер байт под каждый элемент матрицы
** @return указатель на матрицу
**/
t_matrix		*matrix_create(unsigned rows, unsigned cols, size_t size)
{
	t_matrix	*m;
	unsigned	i;

	// выделение памяти под структуру
	m = malloc(sizeof(char *) + sizeof(char *) + sizeof(int) * 2);
	if (!m)
		return (NULL);

	// выделение памяти под массив указателей и их содержимое
	m->arr = (char **)malloc(sizeof(char *) * rows + sizeof(size) * rows * cols);
	if (!m->arr)
	{
		free(m);
		return (NULL);
	}

	// внутренний указатель, указывающий на память с данными массива
	m->_data = (char *)m->arr;
	m->_data += sizeof(char *) * rows;

	// размещение указателей, указывающих на строки матрицы
	i = 0;
	while (i < rows)
	{
		m->arr[i] = (char *)(m->_data + i * cols * size);
		++i;
	}

	// хранение количества колонок и строк рядом с данными
	m->cols = cols;
	m->rows = rows;

	return (m);
}

/**
** @brief Корректно свобождает память аллоцированную под матрицу.
**
** @param matrix указатель на матрицу
** @return void
**/
void			matrix_delete(t_matrix *matrix)
{
	free(matrix->arr);
	free(matrix);
	matrix = NULL;
}
